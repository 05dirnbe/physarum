<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Helper Functions and Utility</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Helper Functions and Utility</h1>  </div>
</div>
<div class="contents">

<p>Helper functions and utility.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="files"></a>
Files</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="utility_8h.html">utility.h</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Graph , typename AnyEdgePropertyMap , typename AnyVertexNamePropertyMap &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility.html#ga792f1f2c9c7f5e2d45e8ad8288d2e4b4">print_edge_property</a> (const Graph &amp;graph, const AnyEdgePropertyMap edge_property, const AnyVertexNamePropertyMap vertex_name_property)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print a given edge property for all edges in the graph.  <a href="#ga792f1f2c9c7f5e2d45e8ad8288d2e4b4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Graph , typename AnyVertexPropertyMap , typename AnyVertexNamePropertyMap &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility.html#ga9bfe27113bb72fa431cba6037e0f753e">print_vertex_property</a> (const Graph &amp;graph, const AnyVertexPropertyMap vertex_property, const AnyVertexNamePropertyMap vertex_name_property)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print a given vertex property for all vertices in the graph.  <a href="#ga9bfe27113bb72fa431cba6037e0f753e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VertexDesciptor &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; VertexDesciptor, <br class="typebreak"/>
VertexDesciptor &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility.html#gac9a89f630177c518dc34a7fb5361f5fd">make_source_sink_pair</a> (VertexDesciptor s, VertexDesciptor t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs and returns a source-sink std::pair.  <a href="#gac9a89f630177c518dc34a7fb5361f5fd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Graph , typename RandNumGen &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename <br class="typebreak"/>
boost::graph_traits&lt; Graph &gt;<br class="typebreak"/>
::vertex_descriptor, typename <br class="typebreak"/>
boost::graph_traits&lt; Graph &gt;<br class="typebreak"/>
::vertex_descriptor &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility.html#gaed027ed120935dabce01dcaf569d51af">make_random_source_sink_pair</a> (const Graph &amp;graph, RandNumGen gen)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs and returns a random source-sink std::pair.  <a href="#gaed027ed120935dabce01dcaf569d51af"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Graph , typename ReverseEdgeMap , typename AnyEdgePropertyMap &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility.html#ga8acf8d5bfd4194740c03ff26983fc3d8">mirror_edge_property_violated</a> (const Graph &amp;graph, const ReverseEdgeMap edge_reverse, const AnyEdgePropertyMap edge_property)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks for each edge if the value of a given edge property is equal to the value of the reversed edge.  <a href="#ga8acf8d5bfd4194740c03ff26983fc3d8"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Helper functions and utility. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaed027ed120935dabce01dcaf569d51af"></a><!-- doxytag: member="utility.h::make_random_source_sink_pair" ref="gaed027ed120935dabce01dcaf569d51af" args="(const Graph &amp;graph, RandNumGen gen)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph , typename RandNumGen &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename boost::graph_traits&lt; Graph &gt;::vertex_descriptor, typename boost::graph_traits&lt; Graph &gt;::vertex_descriptor&gt; make_random_source_sink_pair </td>
          <td>(</td>
          <td class="paramtype">const Graph &amp;&nbsp;</td>
          <td class="paramname"> <em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandNumGen&nbsp;</td>
          <td class="paramname"> <em>gen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs and returns a random source-sink std::pair. </p>
<p>The returned pair always satisfies s != 0. Note that the function cannot check whether the input vertices belong to the same graph. Im not sure whether type deduction can pick these things up or not. Use vertices and descriptors of the same graph to be on the safe side. Switch on optimizations (return value optimization) and have the compiler eliminate unecessary copies.</p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Graph</em>&nbsp;</td><td>A type that models boost::GraphConcept </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RandNumGen</em>&nbsp;</td><td>A type that models boost::PseudoRandomNumberGenerator</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>graph</em>&nbsp;</td><td>A graph </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>gen</em>&nbsp;</td><td>A boost random number functor</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>tmp A s-t pair&lt;vertex_descriptor,vertex_descriptor&gt; </dd></dl>

</div>
</div>
<a class="anchor" id="gac9a89f630177c518dc34a7fb5361f5fd"></a><!-- doxytag: member="utility.h::make_source_sink_pair" ref="gac9a89f630177c518dc34a7fb5361f5fd" args="(VertexDesciptor s, VertexDesciptor t)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertexDesciptor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; VertexDesciptor, VertexDesciptor&gt; make_source_sink_pair </td>
          <td>(</td>
          <td class="paramtype">VertexDesciptor&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertexDesciptor&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs and returns a source-sink std::pair. </p>
<p>Note that the function cannot check wether the input vertices belong to the same graph. Im not sure whether type deduction can pick these things up or not. Use vertices and descriptors of the same graph to be on the safe side. Switch on optimizations (return value optimization) and have the compiler eliminate unecessary copies.</p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>VertexDesciptor</em>&nbsp;</td><td>A type that models boost::GraphConcept&lt; Graph &gt;::vertex_descriptor</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>s</em>&nbsp;</td><td>The source vertex </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>t</em>&nbsp;</td><td>The sink</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>tmp A s-t pair pair&lt;vertex_descriptor,vertex_descriptor&gt;</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000012">Todo:</a></b></dt><dd>Check wether the compile can detect if s and t stem from different graphs. If the error is not detected, make up some Concept for it. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8acf8d5bfd4194740c03ff26983fc3d8"></a><!-- doxytag: member="utility.h::mirror_edge_property_violated" ref="ga8acf8d5bfd4194740c03ff26983fc3d8" args="(const Graph &amp;graph, const ReverseEdgeMap edge_reverse, const AnyEdgePropertyMap edge_property)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph , typename ReverseEdgeMap , typename AnyEdgePropertyMap &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mirror_edge_property_violated </td>
          <td>(</td>
          <td class="paramtype">const Graph &amp;&nbsp;</td>
          <td class="paramname"> <em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ReverseEdgeMap&nbsp;</td>
          <td class="paramname"> <em>edge_reverse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AnyEdgePropertyMap&nbsp;</td>
          <td class="paramname"> <em>edge_property</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks for each edge if the value of a given edge property is equal to the value of the reversed edge. </p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Graph</em>&nbsp;</td><td>A type that models boost::GraphConcept </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ReverseEdgePropertyMap</em>&nbsp;</td><td>A type that models a Readable property map </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AnyEdgePropertyMap</em>&nbsp;</td><td>A type that models a Readable property map</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>graph</em>&nbsp;</td><td>A graph </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>edge_reverse</em>&nbsp;</td><td>Describes the graphs reversed_edge property map </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>edge_property</em>&nbsp;</td><td>Describes an any edge property</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>violation_detected </dd></dl>

</div>
</div>
<a class="anchor" id="ga792f1f2c9c7f5e2d45e8ad8288d2e4b4"></a><!-- doxytag: member="utility.h::print_edge_property" ref="ga792f1f2c9c7f5e2d45e8ad8288d2e4b4" args="(const Graph &amp;graph, const AnyEdgePropertyMap edge_property, const AnyVertexNamePropertyMap vertex_name_property)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph , typename AnyEdgePropertyMap , typename AnyVertexNamePropertyMap &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void print_edge_property </td>
          <td>(</td>
          <td class="paramtype">const Graph &amp;&nbsp;</td>
          <td class="paramname"> <em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AnyEdgePropertyMap&nbsp;</td>
          <td class="paramname"> <em>edge_property</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AnyVertexNamePropertyMap&nbsp;</td>
          <td class="paramname"> <em>vertex_name_property</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print a given edge property for all edges in the graph. </p>
<p>In addition, the connected vertices are listed by name.</p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Graph</em>&nbsp;</td><td>A type that models boost::GraphConcept </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AnyEdgePropertyMap</em>&nbsp;</td><td>A type that models a Readable property map </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AnyVertexNamePropertyMap</em>&nbsp;</td><td>A type that models a Readable property map</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>graph</em>&nbsp;</td><td>A graph </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>edge_property</em>&nbsp;</td><td>Describes an edge property </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>edge_name_property</em>&nbsp;</td><td>Describes a vertex name property </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9bfe27113bb72fa431cba6037e0f753e"></a><!-- doxytag: member="utility.h::print_vertex_property" ref="ga9bfe27113bb72fa431cba6037e0f753e" args="(const Graph &amp;graph, const AnyVertexPropertyMap vertex_property, const AnyVertexNamePropertyMap vertex_name_property)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph , typename AnyVertexPropertyMap , typename AnyVertexNamePropertyMap &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void print_vertex_property </td>
          <td>(</td>
          <td class="paramtype">const Graph &amp;&nbsp;</td>
          <td class="paramname"> <em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AnyVertexPropertyMap&nbsp;</td>
          <td class="paramname"> <em>vertex_property</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AnyVertexNamePropertyMap&nbsp;</td>
          <td class="paramname"> <em>vertex_name_property</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print a given vertex property for all vertices in the graph. </p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Graph</em>&nbsp;</td><td>A type that models boost::GraphConcept </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AnyVertexPropertyMap</em>&nbsp;</td><td>A type that models a Readable property map </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AnyVertexNamePropertyMap</em>&nbsp;</td><td>A type that models a Readable property map</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>graph</em>&nbsp;</td><td>A graph </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>vertex_property</em>&nbsp;</td><td>Describes an edge property </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>vertex_name_property</em>&nbsp;</td><td>Describes a vertex name property </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Tue Jul 17 2012 10:56:39 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
